# Лабораторная работа №7 Вариант: 53221
Список задач:
- [x] Проверить работоспособность команд 
  - [x] help
  - [x] info
  - [x] show
  - [ ] add (DatabaseCollectionMain, 183)
  - [x] update id
  - [x] remove_by_id
  - [x] clear
  - [x] save
  - [x] execute_script
  - [x] exit
  - [x] add_if_min 
  - [x] remove_lower  
  - [x] history
  - [ ] remove_all_by_difficulty (написать реализацию в DatabaseCollectionMain)   
  - [x] filter_starts_with_name 
  - [x] print_descending
  - [x] server_exit

**Доработать программу из лабораторной работы №6 следующим образом:**
*Организовать хранение коллекции в реляционной СУБД (PostgresQL). Убрать хранение коллекции в файле.
*Для генерации поля id использовать средства базы данных (sequence).
*Обновлять состояние коллекции в памяти только при успешном добавлении объекта в БД
*Все команды получения данных должны работать с коллекцией в памяти, а не в БД
*Организовать возможность регистрации и авторизации пользователей. У пользователя есть возможность указать пароль.
*Пароли при хранении хэшировать алгоритмом SHA-1
*Запретить выполнение команд не авторизованным пользователям.
*При хранении объектов сохранять информацию о пользователе, который создал этот объект.
*Пользователи должны иметь возможность просмотра всех объектов коллекции, но модифицировать могут только принадлежащие им.
*Для идентификации пользователя отправлять логин и пароль с каждым запросом.

**Необходимо реализовать многопоточную обработку запросов.**
+ Работа с файлом, хранящим коллекцию.
+ Управление коллекцией объектов.
+ Назначение автоматически генерируемых полей объектов в коллекции.
+ Ожидание подключений и запросов от клиента.
+ Обработка полученных запросов (команд).
+ Сохранение коллекции в файл при завершении работы приложения.
+ Сохранение коллекции в файл при исполнении специальной команды, доступной только серверу (клиент такую команду отправить не может).

**Серверное приложение должно состоять из следующих модулей (реализованных в виде одного или нескольких классов):**
*Для многопоточного чтения запросов использовать создание нового потока (java.lang.Thread)
*Для многопотчной обработки полученного запроса использовать Fixed thread pool
*Для многопоточной отправки ответа использовать ForkJoinPool
*Для синхронизации доступа к коллекции использовать потокобезопасные аналоги коллекции из java.util.concurrent
